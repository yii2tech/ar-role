<?php
/**
 * @link https://github.com/yii2tech
 * @copyright Copyright (c) 2015 Yii2tech
 * @license [New BSD License](http://www.opensource.org/licenses/bsd-license.php)
 */

namespace yii2tech\ar\role;

use yii\base\Behavior;
use yii\base\Model;
use yii\base\UnknownPropertyException;
use yii\db\BaseActiveRecord;

/**
 * RoleBehavior provides support for ActiveRecord relation role composition, which is also known as table inheritance.
 * For example: the database of the University, which have 'students' and 'instructors', which a both 'humans'.
 *
 * Master role inheritance:
 *
 * ```php
 * class Student extends Human // extending `Human` - not `ActiveRecord`!
 * {
 *     public function behaviors()
 *     {
 *         return [
 *             'roleBehavior' => [
 *                 'class' => RoleBehavior::className(), // Attach role behavior
 *                 'roleRelation' => 'studentRole', // specify name of the relation to the slave table
 *                 'roleAttributes' => [
 *                     'roleId' => Human::ROLE_STUDENT
 *                 ],
 *             ],
 *         ];
 *     }
 *
 *     public function getStudentRole()
 *     {
 *         // Here `StudentRole` is and ActiveRecord, which uses 'Student' table :
 *         return $this->hasOne(StudentRole::className(), ['humanId' => 'id']);
 *     }
 * }
 * ```
 *
 * Slave role inheritance:
 *
 * ```php
 * class Instructor extends \yii\db\ActiveRecord // do not extending `Human`!
 * {
 *     public function behaviors()
 *     {
 *         return [
 *             'roleBehavior' => [
 *                 'class' => RoleBehavior::className(), // Attach role behavior
 *                 'roleRelation' => 'human', // specify name of the relation to the master table
 *                 'isOwnerSlave' => true, // indicate that owner is a role slave - not master
 *                 'roleAttributes' => [
 *                     'roleId' => Human::ROLE_INSTRUCTOR
 *                 ],
 *             ],
 *         ];
 *     }
 *
 *     public function getHuman()
 *     {
 *         return $this->hasOne(Human::className(), ['id' => 'humanId']);
 *     }
 * }
 * ```
 *
 * @property BaseActiveRecord $owner
 * @property BaseActiveRecord $roleRelationModel
 *
 * @author Paul Klimov <klimov.paul@gmail.com>
 * @since 1.0
 */
class RoleBehavior extends Behavior
{
    /**
     * @var string name of relation, which corresponds to role entity.
     */
    public $roleRelation;
    /**
     * @var array|null attribute values, which should be applied to the role main entity separating its records,
     * which belong to different roles.
     * For example:
     *
     * ```php
     * [
     *     'roleId' => Human::ROLE_STUDENT
     * ]
     * ```
     *
     * If [[isOwnerSlave]] is 'false', these attributes will be applied to the owner record, if 'true' - to the
     * related one.
     */
    public $roleAttributes;
    /**
     * @var bool whether owner ActiveRecord should be considered as a slave in role relation.
     * If enabled primary key sequence should be generated by related model and then passed to the owner.
     */
    public $isOwnerSlave = false;

    /**
     * @var BaseActiveRecord|null backup of value of the record related via [[roleRelation]] relation
     * at the beginning of [[beforeSave()]]. It is needed to bypass [[BaseActiveRecord::resetDependentRelations()]].
     * @since 1.0.3
     */
    private $roleRelationModelBackup;


    /**
     * Returns the record related via [[roleRelation]] relation.
     * If no related record exists - new one will be instantiated.
     * @return BaseActiveRecord role related model.
     */
    public function getRoleRelationModel()
    {
        $model = $this->owner->{$this->roleRelation};
        if (is_object($model)) {
            return $model;
        }

        $relation = $this->owner->getRelation($this->roleRelation);
        $class = $relation->modelClass;
        $model = new $class();
        $this->owner->populateRelation($this->roleRelation, $model);

        return $model;
    }

    // Property Access Extension:

    /**
     * PHP getter magic method.
     * This method is overridden so that variation attributes can be accessed like properties.
     *
     * @param string $name property name
     * @throws UnknownPropertyException if the property is not defined
     * @return mixed property value
     */
    public function __get($name)
    {
        try {
            return parent::__get($name);
        } catch (UnknownPropertyException $exception) {
            $model = $this->getRoleRelationModel();
            if ($model->hasAttribute($name) || $model->canGetProperty($name)) {
                return $model->$name;
            }
            throw $exception;
        }
    }

    /**
     * PHP setter magic method.
     * This method is overridden so that role model attributes can be accessed like properties.
     * @param string $name property name
     * @param mixed $value property value
     * @throws UnknownPropertyException if the property is not defined
     */
    public function __set($name, $value)
    {
        try {
            parent::__set($name, $value);
        } catch (UnknownPropertyException $exception) {
            $model = $this->getRoleRelationModel();
            if ($model->hasAttribute($name) || $model->canSetProperty($name)) {
                $model->$name = $value;
            } else {
                throw $exception;
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function canGetProperty($name, $checkVars = true)
    {
        if (parent::canGetProperty($name, $checkVars)) {
            return true;
        }
        $model = $this->getRoleRelationModel();
        return $model->hasAttribute($name) || $model->canGetProperty($name, $checkVars);
    }

    /**
     * {@inheritdoc}
     */
    public function canSetProperty($name, $checkVars = true)
    {
        if (parent::canSetProperty($name, $checkVars)) {
            return true;
        }
        $model = $this->getRoleRelationModel();
        return $model->hasAttribute($name) || $model->canSetProperty($name, $checkVars);
    }

    // Method Access Extension:

    /**
     * {@inheritdoc}
     */
    public function __call($name, $params)
    {
        $model = $this->getRoleRelationModel();
        if ($model->hasMethod($name)) {
            return call_user_func_array([$model, $name], $params);
        }

        return parent::__call($name, $params);
    }

    /**
     * {@inheritdoc}
     */
    public function hasMethod($name)
    {
        if (parent::hasMethod($name)) {
            return true;
        }
        $model = $this->getRoleRelationModel();
        return $model->hasMethod($name);
    }

    // Events :

    /**
     * {@inheritdoc}
     */
    public function events()
    {
        return [
            Model::EVENT_BEFORE_VALIDATE => 'beforeValidate',
            Model::EVENT_AFTER_VALIDATE => 'afterValidate',
            BaseActiveRecord::EVENT_BEFORE_INSERT => 'beforeSave',
            BaseActiveRecord::EVENT_BEFORE_UPDATE => 'beforeSave',
            BaseActiveRecord::EVENT_AFTER_INSERT => 'afterSave',
            BaseActiveRecord::EVENT_AFTER_UPDATE => 'afterSave',
            BaseActiveRecord::EVENT_BEFORE_DELETE => 'beforeDelete',
            BaseActiveRecord::EVENT_AFTER_DELETE => 'afterDelete',
        ];
    }

    /**
     * Handles owner 'beforeValidate' event, ensuring role attributes are populated,
     * ensuring the correct validation.
     * @param \yii\base\ModelEvent $event event instance.
     * @since 1.0.2
     */
    public function beforeValidate($event)
    {
        if (empty($this->roleAttributes)) {
            return;
        }

        if ($this->isOwnerSlave) {
            $model = $this->getRoleRelationModel();
            foreach ($this->roleAttributes as $name => $value) {
                $model->$name = $value;
            }
            return;
        }

        foreach ($this->roleAttributes as $name => $value) {
            $this->owner->$name = $value;
        }
    }

    /**
     * Handles owner 'afterValidate' event, ensuring role model is validated as well
     * in case it have been fetched.
     * @param \yii\base\Event $event event instance.
     */
    public function afterValidate($event)
    {
        if (!$this->owner->isRelationPopulated($this->roleRelation)) {
            return;
        }
        $model = $this->getRoleRelationModel();
        if (!$model->validate()) {
            $this->owner->addErrors($model->getErrors());
        }
    }

    /**
     * Handles owner 'beforeInsert' and 'beforeUpdate' events, ensuring role model is saved.
     * @param \yii\base\ModelEvent $event event instance.
     */
    public function beforeSave($event)
    {
        // Backup to bypass [[BaseActiveRecord::resetDependentRelations()]] :
        if ($this->owner->isRelationPopulated($this->roleRelation)) {
            $this->roleRelationModelBackup = $this->owner->{$this->roleRelation};
        } else {
            $this->roleRelationModelBackup = null;
        }

        // Master :
        if (!$this->isOwnerSlave) {
            if (!empty($this->roleAttributes)) {
                foreach ($this->roleAttributes as $name => $value) {
                    $this->owner->$name = $value;
                }
            }
            return;
        }

        // Slave :
        $relation = $this->owner->getRelation($this->roleRelation);

        if ($this->roleRelationModelBackup === null) {
            $ownerLinkPopulated = true;
            foreach ($relation->link as $to => $from) {
                if ($this->owner->{$from} === null) {
                    $ownerLinkPopulated = false;
                    break;
                }
            }
            if ($ownerLinkPopulated) {
                return;
            }
        }

        $model = $this->getRoleRelationModel();

        if (!empty($this->roleAttributes)) {
            foreach ($this->roleAttributes as $name => $value) {
                $model->$name = $value;
            }
        }

        $model->save(false);

        foreach ($relation->link as $to => $from) {
            $this->owner->{$from} = $model->{$to};
        }

        $this->roleRelationModelBackup = $model;
        $this->owner->populateRelation($this->roleRelation, $model);
    }

    /**
     * Handles owner 'afterInsert' and 'afterUpdate' events, ensuring role model is saved
     * in case it has been fetched before.
     * @param \yii\base\ModelEvent $event event instance.
     */
    public function afterSave($event)
    {
        // Restore backup :
        if ($this->roleRelationModelBackup !== null) {
            if (!$this->owner->isRelationPopulated($this->roleRelation)) {
                $this->owner->populateRelation($this->roleRelation, $this->roleRelationModelBackup);
            }
            $this->roleRelationModelBackup = null;
        }

        // Slave :
        if ($this->isOwnerSlave) {
            return;
        }

        // Master :
        if (!$this->owner->isRelationPopulated($this->roleRelation)) {
            return;
        }

        $model = $this->getRoleRelationModel();

        $relation = $this->owner->getRelation($this->roleRelation);
        foreach ($relation->link as $to => $from) {
            $model->{$to} = $this->owner->{$from};
        }

        $model->save(false);
    }

    /**
     * Handles owner 'beforeDelete' events, ensuring role model is deleted as well.
     * @param \yii\base\ModelEvent $event event instance.
     */
    public function beforeDelete($event)
    {
        if ($this->isOwnerSlave) {
            return;
        }
        $this->deleteRoleRelationModel();
    }

    /**
     * Handles owner 'beforeDelete' events, ensuring role model is deleted as well.
     * @param \yii\base\ModelEvent $event event instance.
     */
    public function afterDelete($event)
    {
        if (!$this->isOwnerSlave) {
            return;
        }
        $this->deleteRoleRelationModel();
    }

    /**
     * Deletes related role model.
     */
    protected function deleteRoleRelationModel()
    {
        $model = $this->owner->{$this->roleRelation};
        if (is_object($model)) {
            $model->delete();
        }
    }
}